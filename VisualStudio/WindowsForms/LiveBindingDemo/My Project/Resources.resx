<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Form1_getOnEventLinkLabel_LinkClicked_HelpText">
    <value xml:space="preserve">On a TextBox, use "Bind to Point" command and select the OPC item and property you want to get (alternatively, use  "Edit Live Bindings" command, "Add" a PointBinding, and configure its ServerDescriptor and PropertyDescriptor). 

In order to have the Get invoked when the button is pressed, set the GetEventSource.SourceComponent to the Button control; the SourceMember of the GetEventSource will be automatically set to the Click event. This causes the Click on the button execute the Get operation, i.e. obtain the OPC property value and store it into the TextBox.</value>
  </data>
  <data name="Form1_automaticGetLinkLabel_LinkClicked_HelpText">
    <value xml:space="preserve">On a PointBinder, edit the BindingGroups collection, "Add" a new binding group, and set its AutoGet property to True. 

On a TextBox, use "Bind to OPC-DA Property" command and select the OPC item and property you want to get. Then, use the "Edit Live Bindings" command, and set the BindingGroup property of the property binding to the binding group you have created earlier. The Get operation is automatically executed for all property bindings in this group when the form loads.</value>
  </data>
  <data name="Form1_automaticSubscriptionLinkLabel_LinkClicked_HelpText">
    <value xml:space="preserve">If you have not done so yet, drag the DAConnectivity component from the Toolbox to the form (this is a common step for all binding tasks). 

Use the "Bind to OPC-DA Item" command on the target control, and select the source OPC server and OPC item. 

That's it. You can verify the result immediately, without recompiling your application, by using the "Design Online" command on the BindingExtender component.</value>
  </data>
  <data name="Form1_automaticReadLinkLabel_LinkClicked_HelpText">
    <value xml:space="preserve">On a PointBinder, edit the BindingGroups collection, "Add" a new binding group, set its AutoGet property to True, and make sure that its AutoSubscribe property is set to False. 

On a TextBox, use "Bind to Point" command and select the OPC item you want to read. Then, use the "Edit Live Bindings" command, and set the BindingGroup property of the item binding to the binding group you have created earlier. The Read operation is automatically executed for all item bindings in this group when the form loads.</value>
  </data>
  <data name="Form1_readOnCustomEventLinkLabel_LinkClicked_HelpText">
    <value xml:space="preserve">On a TextBox, use "Bind to Point" command and select the OPC item you want to read (alternatively, use  "Edit Live Bindings" command, "Add" a PropertyBinding, and configure its ServerDescriptor and ItemDescriptor). 

Then, use the "Edit Live Bindings" command, and for MappingOperations property, leave just Read checked (and uncheck the Subscribe). In order to have the Read invoked when the button is pressed, set the ReadEventSource.SourceComponent to the Button control; the SourceMember of the GetEventSource will be automatically set to the Click event. This causes the Click on the button execute the Read operation, i.e. obtain the OPC item value and store it into the TextBox. 

Note: In order to read multiple items at once on a custom event, it is suggested that you set up a binding group under the PointBinder, assign the bindings to the group, and link the ReadEventSource just once, on the binding group. </value>
  </data>
  <data name="Form1_errorProviderLinkLabel_LinkClicked_HelpText">
    <value xml:space="preserve">Drag the ErrorProvider extender (standard Microsoft component) from the toolbox to the form. Configure the binding in a usual way. 

Then, use the "Edit Live Bindings" command, "Clone" the existing binding, and change the cloned binding as follows: Set the MappingKind to ErrorMessage. Set the ValueTarget.ExtenderProvider to the ErrorProvider component on your form, and set the ValueTarget.TargetMember to the Error member. All in all, this will cause the error message from the OPC item be stored into the error text displayed by the ErrorProvider for the control. 

Note: If you configure this with explicit Read, Write or Get operations (not with Subscription), you need to set up a binding group, assign related bindings to the same group, and have the operation invoked on a binding group.
</value>
  </data>
  <data name="Form1_stringFormattingLinkLabel_LinkClicked_HelpText">
    <value xml:space="preserve">Bind the OPC item to the TextBox or similar control as usually. 

Then, use the "Edit Live Bindings" command on the control, and set the StringFormat property on the item binding as needed, using all standard .NET formatting capabilities. {0} in the formatting string represents the value to be formatted. For example, {0:F3} means a floating point value formatted with 3 decimal places.</value>
  </data>
  <data name="Form1_changeBackgroundLinkLabel_LinkClicked_HelpText">
    <value xml:space="preserve">Drag the StatusToColorConverter component from the toolbox to the form. Bind the OPC item to your control as usually. 

Then, use the "Edit Live Bindings" command, "Clone" the existing binding, and change the cloned binding as follows: Set the MappingKind to StatusInfo. Set the ValueTarget.TargetMember to the BackColor (or other suitable) property of your control, and for the Converter property, select the StatusToColorConverter you have placed to the form earlier. This will cause the status information from the OPC item be converted to one of configurable colors, and change the background color of the control appropriately. </value>
  </data>
  <data name="Form1_bindingKindsLinkLabel_LinkClicked_HelpText">
    <value xml:space="preserve">Bind the OPC item to your control as usually. 

Then, use the "Edit Live Bindings" command on the control, and for the MappingKind property, select the kind of binding you want. </value>
  </data>
  <data name="Form1_extendersLinkLabel_LinkClicked_HelpText">
    <value xml:space="preserve">Drag the ToolTip extender (standard Microsoft component), or other extender provider you need, from the toolbox to the form. Configure the binding in a usual way. 
Then, use the "Edit Live Bindings" command, "Clone" the existing binding, and change the cloned binding as follows: Set the ValueTarget.ExtenderProvider to the ToolTip (extender provider) component on your form, and set the ValueTarget.TargetMember to the Tooltip member. Set the MappingKind to Vtq (or Timestamp, Quality, or whatever you'll want to be displayed in the tooltip). This will cause the additional information from the OPC item be displayed by the ToolTip extender provider for the control. </value>
  </data>
  <data name="Form1_subscribeAndWriteLinkLabel_LinkClicked_HelpText">
    <value xml:space="preserve">On the target control, use "Bind to OPC-DA Item" command and select the OPC item you want to bind to. 
Then, use the "Edit Live Bindings" command, and for MappingOperations property, add a check next to the Write operation. In order to have the Write invoked when the control changes, set the WriteEventSource.SourceComponent to your control; the SourceMember of the GetEventSource will be automatically determined, but you can change it, if you want to link to a different event. 

Note: Some controls will require you to set the ItemDescriptor.RequestedDataType so that the OPC value type matches the type of the target property. </value>
  </data>
  <data name="Form1_writeSingleLinkLabel_LinkClicked_HelpText">
    <value xml:space="preserve">On a TextBox, use "Bind to OPC-DA Item" command and select the OPC item you want to write.
 
Then, use the "Edit Live Bindings" command, and for the MappingOperations options, select only "Write". In order to have the Write invoked when the button is pressed, set the WriteEventSource.SourceComponent to the Button control; the SourceMember of the WriteEventSource will be automatically set to the Click event. This causes the Click on the button execute the Write operation, i.e. obtain the value from the control and Write it into the OPC item.</value>
  </data>
  <data name="Form1_writeGroupLinkLabel_LinkClicked_HelpText">
    <value xml:space="preserve">On a PointBinder, edit the BindingGroups collection, "Add" a new binding group, set its AutoSubscribe property to False, and set its WriteEventSource.SourceComponent to the button that should invoke the Write. 

On each of the value controls involved, use "Bind to OPC-DA Item" command and select the OPC item you want to write. Then, use the "Edit Live Bindings" command, and for the MappingOperations options, select only "Write". Also, set the BindingGroup property of the item binding to the binding group you have created earlier. The Write operation will be executed for all item  bindings in this group when the button is clicked.</value>
  </data>
  <data name="Form1_displayWriteErrorsLinkLabel_LinkClicked_HelpText">
    <value xml:space="preserve">On a PointBinder, edit the BindingGroups collection, "Add" a new binding group, set its AutoSubscribe property to False, and set its WriteEventSource.SourceComponent to the button that should invoke the Write. 

Drag the ErrorProvider extender (standard Microsoft component) from the toolbox to the form. 
Configure the binding in a usual way. Use the "Edit Live Bindings" command, and for the MappingOperations options, select only "Write", and set the BindingGroup property of the item binding to the binding group you have created earlier. Then, "Clone" the existing binding, and change the cloned binding as follows: Set the MappingKind to ErrorMessage. Set the ValueTarget.ExtenderProvider to the ErrorProvider component on your form, and set the ValueTarget.TargetMember to the Error member. This will cause the error message from the OPC item be stored into the error text displayed by the ErrorProvider for the control. 
</value>
  </data>
</root>